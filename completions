#!/usr/bin/env ruby

# Adapted from http://onrails.org/articles/2006/08/30/namespaces-and-rake-command-completion
#
# Save this somewhere, chmod 755 it, then add
#
#   complete -C path/to/this/script -o default <command>
#
# to your ~/.bashrc, where <command> is one of the Complete::* classes defined in this script.

require 'fileutils'

module Complete

  # Pass in bash's ENV['COMP_LINE'], and this will attempt to instantiate
  # the appropriate class and output the possible completions to standard
  # output. If the command is unsupported, it does nothing.
  def self.execute(line)
    puts const_get(line.split.first.capitalize).new(line)
  rescue NameError => e
  end
end


# Base class for command completers.
class Complete::Base
  attr_accessor :line

  def initialize(line)
    self.line = line
  end

  # Subclasses may return false from this method if they can't provide
  # completions for some reason.
  def ready?
    true
  end

  # If ready?, joins all the matches with a newline, which is what bash
  # expects. Otherwise, returns the empty string.
  def to_s
    ready? ? matches.join("\n") : ''
  end

private

  # Post-processes all the potential matches based on the candidate.
  def matches
    post_process(candidate.empty? ? completions : completions.select { |c| c.start_with?(candidate) })
  end

  # The list of all arguments passed to the command.
  def arguments
    @arguments ||= line.split(/\s+/, -1)[1..-1]
  end

  # The word we're attempting to complete.
  def candidate
    @candidate ||= arguments.last.strip
  end

  # Provides a hook for performing additional processing of the potential matches
  # after the initial search.
  def post_process(possible_completions)
    possible_completions
  end
end


# Provides completions for basic Git commands and completion of local branch
# names for branch operations (checkout, merge, etc.).
class Complete::Git < Complete::Base

  # Only allows completion of the first argument to git. So "git ch" completes
  # to "git checkout", but "git rm me" does not (necessarily) complete to
  # "git rm merge".
  #
  # Makes an exception for branch commands, like checkout and merge. In that
  # case, it attempts to complete local branch names. See #completions.
  def ready?
    arguments.one? || branch_command?
  end

  # If the last argument is a command that expects a branch name, returns a list
  # of local branches so as to provide completion of branch names. Otherwise,
  # returns a basic list of common commands.
  def completions
    if branch_command?
      `git branch --no-color | perl -lpe 's/^\\*?\\s+//'`.split("\n").map(&:strip)
    else
      %w{add bisect branch checkout clone commit diff fetch grep init log merge mv pull push rebase reset rm show stash status tag}
    end
  end

private

  def branch_command?
    %w{br branch checkout co merge pull push}.include?(arguments.first)
  end
end


# Provides completions for Rake tasks based on the Rakefile in the current
# directory. The list of tasks is cached in ~/.rake_completions/<expanded/path>/completions
# so you don't need to wait on "rake -T" to run every time you attempt to
# complete. If your tasks change, simply remove that file and it will be
# regenerated the next time you attempt to complete.
class Complete::Rake < Complete::Base

  # Returns true if the current directory contains a Rakefile, false if not.
  def ready?
    File.file?(File.join(Dir.pwd, 'Rakefile'))
  end

  # Returns the list of tasks, caching it if necessary.
  def completions
    path = File.join(ENV['HOME'], '.rake_completions', Dir.pwd[1..-1], 'completions')

    if File.exists?(path)
      File.read(path)
    else
      `bundle exec rake --silent --tasks | awk '{ print $2 }'`.tap do |tasks|
        FileUtils.mkpath(File.dirname(path))
        File.open(path, 'w') { |f| f.puts tasks }
      end
    end.split("\n")
  end

private

  # Handles task namespacing (db:migrate:status). Bash expects the completions
  # to exclude colons already included in the candidate word, so this returns
  # the portions of the string after that.
  def post_process(possible_completions)
    if candidate.include?(':')
      possible_completions.map { |c| c.split(':', candidate.count(':') + 1).last }
    else
      possible_completions
    end
  end
end

class Complete::Bundle < Complete::Rake; end


### Main ###


Complete.execute(ENV['COMP_LINE'])
